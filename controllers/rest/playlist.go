package rest

import (
	"crypto/ecdsa"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/dgrijalva/jwt-go/v4"
	"github.com/gofiber/fiber/v2"
	"github.com/kobums/playlist/controllers"
	"github.com/kobums/playlist/models"
)

type PlaylistController struct {
	controllers.Controller
}

func (c *PlaylistController) generateToken() (string, error) {
	teamID := os.Getenv("TEAM_ID")
	keyID := os.Getenv("KEY_ID")

	privateKeyData, err := os.ReadFile("AuthKey_GXVS6H2456.p8")
	if err != nil {
		return "", err
	}

	block, _ := pem.Decode(privateKeyData)
	if block == nil {
		return "", fmt.Errorf("failed to parse PEM block containing the key")
	}

	parsedKey, err := x509.ParsePKCS8PrivateKey(block.Bytes)
	if err != nil {
		return "", fmt.Errorf("failed to parse private key: %v", err)
	}

	ecdsaKey, ok := parsedKey.(*ecdsa.PrivateKey)
	if !ok {
		return "", fmt.Errorf("not ECDSA private key")
	}

	token := jwt.NewWithClaims(jwt.SigningMethodES256, jwt.MapClaims{
		"iss": teamID,
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Hour).Unix(),
	})

	token.Header["kid"] = keyID

	tokenString, err := token.SignedString(ecdsaKey)
	if err != nil {
		return "", err
	}

	return tokenString, nil
}

func (c *PlaylistController) createPlaylist(jwtToken string, playlistName string) (string, error) {
	// API URL 설정
	url := "https://api.music.apple.com/v1/me/library/playlists"

	// 요청 본문 설정
	requestBody := fmt.Sprintf(`{
        "attributes": {
            "name": "%s",
            "description": "Generated by MusicKit API"
        }
    }`, playlistName)

	// 요청 생성
	req, err := http.NewRequest("POST", url, strings.NewReader(requestBody))
	if err != nil {
		return "", err
	}

	// 헤더 설정
	userToken := os.Getenv("USER_TOKEN")
	req.Header.Set("Content-Type", "application/json")

	req.Header.Set("Authorization", "Bearer "+jwtToken)
	req.Header.Set("Music-User-Token", userToken)

	// 클라이언트 생성 및 요청 전송
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// 응답 처리
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	// 응답 디버그 출력
	// fmt.Println("Response Body:", string(body))

	var result map[string]interface{}
	if err := json.Unmarshal(body, &result); err != nil {
		return "", err
	}

	data, ok := result["data"]
	if !ok {
		return "", errors.New("response does not contain data field")
	}

	playlists, ok := data.([]interface{})
	if !ok {
		return "", fmt.Errorf("expected []interface{}, got %T", data)
	}

	if len(playlists) == 0 {
		return "", errors.New("no playlists created")
	}

	playlist, ok := playlists[0].(map[string]interface{})
	if !ok {
		return "", fmt.Errorf("expected map[string]interface{}, got %T", playlists[0])
	}

	playlistId, ok := playlist["id"].(string)
	if !ok {
		return "", errors.New("playlist does not contain id field")
	}

	return playlistId, nil
}

func (c *PlaylistController) listPlaylists(jwtToken, userToken string) ([]map[string]interface{}, error) {
	url := "https://api.music.apple.com/v1/me/library/playlists?limit=100"

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+jwtToken)
	req.Header.Set("Music-User-Token", userToken)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// 상태 코드 확인
	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("unexpected status code: %d, body: %s", resp.StatusCode, string(body))
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// 응답 내용 디버깅
	// fmt.Println("Response Body:", string(body))

	var result map[string]interface{}
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, fmt.Errorf("error unmarshalling JSON: %v, body: %s", err, string(body))
	}

	playlistsData, ok := result["data"].([]interface{})
	if !ok {
		return nil, fmt.Errorf("expected []interface{}, got %T", result["data"])
	}

	var playlists []map[string]interface{}
	for _, item := range playlistsData {
		playlist, ok := item.(map[string]interface{})
		if !ok {
			continue
		}
		playlists = append(playlists, playlist)
	}

	return playlists, nil
}

type PlaylistRequest struct {
	Title     string `json:"title"`
	Playlist  string `json:"playlist"`
	UserToken string `json:"userToken"`
}

func (c *PlaylistController) parsePlaylist(playlist string) []string {
	lines := strings.Split(playlist, "\n")
	var songs []string

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "playlistname:") {
			// 이 부분은 playlist 이름을 처리하는 부분이므로 필요하지 않다면 삭제할 수 있습니다.
			continue
		} else {
			song := regexp.MustCompile(`\s*\d+:\d+`).ReplaceAllString(line, "")
			songs = append(songs, strings.TrimSpace(song))
		}
	}

	return songs
}

func (c *PlaylistController) GetDeveloperToken() fiber.Map {
	authController := &AuthController{}
	authController.LoadEnv()
	token, err := c.generateToken()
	if err != nil {
		fmt.Println("Error reading file:", err)
	}

	return fiber.Map{
		"code":           "ok",
		"developerToken": token,
	}
}

func (c *PlaylistController) HandlePlaylist(item *models.Playlist) {
	jwtToken := item.DeveloperToken
	if jwtToken == "" {
		fmt.Println("no jwtToken provided")
	}

	playlistName := item.Title
	songs := c.parsePlaylist(item.List)

	playlists, err := c.listPlaylists(jwtToken, item.UserToken)
	if err != nil {
		fmt.Println("failed to retrieve playlists: %w", err)
	}

	var playlistID string
	found := false
	for _, playlist := range playlists {
		fmt.Println(playlist["attributes"].(map[string]interface{})["name"].(string))
		// if playlistName == playlist["attributes"].(map[string]interface{})["name"].(string) {
		// 	if id, ok := playlist["id"].(string); ok {
		// 		playlistID = id
		// 		found = true
		// 		break
		// 	}
		// }
		attributes, ok := playlist["attributes"].(map[string]interface{})
		if !ok {
			// attributes가 예상한 타입이 아니거나 nil일 경우
			fmt.Println("attributes is nil or not a map[string]interface{}")
			continue
		}

		name, ok := attributes["name"].(string)
		if !ok || name == "" {
			// name이 string 타입이 아니거나 nil일 경우
			fmt.Println("name is nil or not a string")
			continue
		}

		if playlistName == name {
			playlistID, ok = playlist["id"].(string)
			if !ok || playlistID == "" {
				fmt.Println("playlist ID is nil or not a string")
				continue
			}
			found = true
			break
		}
	}

	if !found {
		playlistID, err = c.createPlaylist(jwtToken, playlistName)
		if err != nil {
			fmt.Println("failed to create playlist: %w", err)
		}
	}

	songController := &SongController{}
	results := []map[string]interface{}{}

	for _, song := range songs {
		songDetails := strings.Split(song, " - ")
		if len(songDetails) != 2 {
			results = append(results, map[string]interface{}{
				"song":   song,
				"status": false,
			})
			continue
		}

		searchTerm := fmt.Sprintf("%s %s", songDetails[0], songDetails[1])
		songID, err := songController.searchSong(jwtToken, item.UserToken, searchTerm)

		if err != nil {
			results = append(results, map[string]interface{}{
				"song":   song,
				"status": false,
			})
			continue
		}

		err = songController.addTrackToPlaylist(jwtToken, item.UserToken, playlistID, songID)
		if err != nil {
			results = append(results, map[string]interface{}{
				"song":   song,
				"status": false,
			})
		} else {
			results = append(results, map[string]interface{}{
				"song":   song,
				"status": true,
			})
		}
	}

	c.Set("result", results)
}
